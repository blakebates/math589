# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MWSyk12dIr6YdXHSB6CUHA-utdxAwNkI
"""

from scipy.integrate import solve_ivp
import numpy as np
import math

def ham(vec):
    """
    Calculates the Hamiltonian for a given state and control variables.

    Parameters:
    vec (list): List containing time, generalized coordinates and costates.

    Returns:
    float: Value of the Hamiltonian.
    """
    t, p, l1, l2 = vec
    return ((p**2)/2) - math.cos(t) + 1 + ((-math.cos(t) * l2)**2)/2 + l1*p + l2*(-0.1*p + math.sin(t) + (-math.cos(t) * l2) * math.cos(t))

def find_cost(t, vect):
    """
    Computes the cost associated with a trajectory over time t.

    Parameters:
    t (float): Time at which the cost is evaluated.
    vect (np.array): State vector at time t.

    Returns:
    float: Computed cost.
    """
    theta_dd = ((vect[1] ** 2)/2) - math.cos(vect[0]) + ((math.cos(vect[0])*vect[3])**2/ 2) + 1
    x_dot = np.array([vect[0], theta_dd])
    lambda_t = np.array([vect[2], vect[3]])
    cost = np.dot(lambda_t, x_dot)
    return cost * t

def f(t, y):
    """
    System dynamics for the state and costate equations.

    Parameters:
    t (float): Time variable
    y (np.array): Current state vector

    Returns:
    np.array: Derivatives of the state and costate
    """
    d_theta = -1 * y[1]
    d_phi = 0.1 * y[1] + (math.cos(y[0]) ** 2) * y[3] - math.sin(y[0])
    d_costate_1 = -1 * (math.cos(y[0]) * math.sin(y[0]) * (y[3]**2)) + y[3] * (2 * math.cos(y[0]) * math.sin(y[0]) * y[3] + math.cos(y[0])) + math.sin(y[0])
    d_costate_2 = y[1] - 0.1 * y[3] + y[2]
    return np.array([d_theta, d_phi, d_costate_1, d_costate_2])

def find_closest_state(P, theta0, phi0, prev_angle, angle, res):
    """
    Iteratively finds the closest state from a given range of angles by solving the system dynamics.

    Parameters:
    P (np.array): Transformation matrix computed from system linearization.
    theta0 (float): Target initial angle.
    phi0 (float): Target initial angular velocity.
    prev_angle (float): Starting angle for search in degrees.
    angle (float): Ending angle for search in degrees.
    res (float): Initial resolution in degrees.

    Returns:
    tuple: Closest state and the corresponding time.
    """
    prev_angle_rad = math.radians(prev_angle)
    angle_rad = math.radians(angle)
    t_span = (0, 5)
    radius = math.sqrt(theta0**2 + phi0**2)
    min_resolution = 0.001
    closest_solution = None
    closest_time = 0
    while res >= min_resolution:
        states = np.linspace(prev_angle_rad, angle_rad, int((angle_rad - prev_angle_rad) / res) + 1)
        closest_distance = float('inf')
        for j in states:
            x = radius * np.array([math.cos(j), math.sin(j)])
            costate = np.matmul(P, x.reshape(2,1)).reshape(1,2)[0]
            solution = solve_ivp(f, t_span, [x[0], x[1], costate[0], costate[1]], method='RK45')
            for sol_time, sol_state in zip(solution.t, solution.y.T):
                sol_dist = np.linalg.norm([theta0 - sol_state[0], phi0 - sol_state[1]])
                if sol_dist < closest_distance:
                    closest_solution = sol_state
                    closest_time = sol_time
                    closest_distance = sol_dist
        prev_angle_rad = max(prev_angle_rad, j - res)
        angle_rad = min(angle_rad, j + res)
        res *= 0.1
    if closest_solution is None:
        raise ValueError("No solution found within the specified range.")
    return closest_solution, closest_time

def control_pendulum(theta0, phi0, alpha=0):
    """
    Controls a pendulum to a resting state using optimal control theory,
    minimizing the cost function.

    Parameters:
    theta0 (float): Initial angle of the pendulum.
    phi0 (float): Initial angular velocity of the pendulum.
    alpha (float): Damping coefficient, representing friction or other resistive forces.

    Returns:
    tuple: Optimal costates and the minimum cost.
    """
    A = np.array([[0, 1], [1, -alpha]])
    Q = np.array([[1, 0], [0, 1]])
    BRB = np.array([[0, 0], [0, -1]])
    H = np.block([[A, BRB], [-Q, -A]])

    eigvals, eigvecs = np.linalg.eig(H)
    stable_eigvecs = []

    for i, val in enumerate(eigvals):
        if np.real(val) < 0:
            stable_eigvecs.append(eigvecs[:, i])

    if not stable_eigvecs:
        raise ValueError("No stable eigenvectors found, system may not be stabilizable.")

    V = np.column_stack(stable_eigvecs)
    V_s1 = V[:2, :]
    V_s2 = V[2:, :]

    try:
        P = np.real(np.matmul(V_s2, np.linalg.inv(V_s1)))
    except np.linalg.LinAlgError:
        raise np.linalg.LinAlgError("Matrix inversion failed. The control system may not be properly defined.")

    closest, t = find_closest_state(P, theta0, phi0, 0, 360, 10)

    lambda1 = closest[2]
    lambda2 = closest[3]

    x = np.array([closest[0], closest[1]])
    J = find_cost(t, closest)

    return (lambda1, lambda2), J

print(control_pendulum(0.10938397823369476, -0.028311920307478075, 0.1))